# Transaction Isolation Level (트랜잭션 격리 수준)

트랜잭션 격리 수준이란 여러 개의 트랜잭션들이 동시에 진행될 때 고립 수준을 정해놀 수 있다

즉 트랜잭션끼리 데이터의 허용범위를 설정할 수 있다 

간단히 말해서 트랜잭션이 처리되면서 다른 트랜잭션에 데이터를 가져올 수 있는 게 가능하냐 불가능하냐의 정도를 결정할 수 있습니다

하지만 고립 수준이 높을수록 일관성은 보장되나 동시성이 떨어집니다 (성능 저하)

고립수준은 크게 4가지 입니다

- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

아래로 내려갈수록 고립 수준이 높아지며 동시성도 떨어진다

---

## READ UNCOMMITTED
Commit이나 RollBack에 상관없이 다른 트랜잭션이 조회했을 때 변경된 값을 보여줍니다

하지만 더티 리드(Dirty Read)가 발생하여 격리 수준을 한 단계 높이거나 해야 할 거 같습니다

> A트랜잭션에서 kkyu값을 가지고 있는 name컬럼을 77kkyu로 변경함 (커밋하기 전)
> 
> B트랜잭션에서 name컬럼을 조회했을 때 name의 값은 77kkyu로 조회됩니다 - 더티 리드(Dirty Read)
> 
> A트랜잭션에서 에러가 나서 롤백함
> 
> B트랜잭션에서는 그대로 name컬럼의 값을 77kkyu로 인식하여 수행합니다

---

## READ COMMITTED
Commit이 되여야만 다른 트랜잭션에서 사용이 가능하다

> A트랜잭션에서 kkyu값을 가지고 있는 name컬럼을 77kkyu로 변경함 (커밋하기 전)
>
> B트랜잭션에서 name컬럼을 조회했을 때 name의 값은 kkyu로 조회됩니다
>
> A트랜잭션에서 커밋을 수행함 
> 
> B트랜잭션에서 다시 name컬럼을 조회함, 77kky로 조회됨

언뜻 보면 해결된 것 같지만 여기서 문제점은 NON-REPETABLE READ이 발생된다는 점입니다

NON-REPETABLE READ - 하나의 트랜잭션에서 두 번 조회했을 때 다른 결과를 가져올 수 있습니다.
하나의 트랜잭션에서 같은 쿼리를 실행하면 똑같은 결과 값을 가져와야 한다는 정합성에 어긋납니다 

---

## REPEATABLE READ
Commit이 완료된 상태에서만 다른 트랜잭션에서 사용이 가능하다 (트랜잭션이 시작되기 전)

Dirty Read, NON-REPETABLE READ의 문제점은 발생하지 않는다

Mysql에서는 REPEATABLE READ를 기본으로 사용하고 있다

그리고 트랜잭션마다 ID를 부여한다

READ COMMITTED랑 비슷한 거 같지만 REPEATABLE READ는 undo 영역에서 백업된 데이터를 가져온다
- undo영역에 백업해두고 데이터를 변경함
- 이러한 방식을 MVCC(Multi Version Concurrency Control)라고 부른다

> 10번 세션의 트랜잭션에서 id가 1인 유저를 조회
> 
> 13번 세션의 트랜잭션에서 id가 1인 유저의 이름을 변경, 커밋
> 
> 10번 세션의 트랜잭션에서 id가 1인 유저를 다시 조회
> 
> 13번 세션의 트랜잭션에서 유저 이름을 변경했지만 변경되어 있지 않음, undo영역의 데이터를 반환함(변경되기 전 이름)

자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 커밋된 것만 보여준다

반대로 생각하면 Phantom READ 현상의 문제점이 발생한다
(Insert에서만 발생 && InnoDB 스토리지 엔진에서는 발생하지 않는다)

Phantom READ - 한 트랜잭션에서 같은 데이터를 두 번 조회를 했을 경우 첫 번째 조회에서는 보이고, 두 번째 조회에서는 안 보이는 현상

이를 방지하기 위해 쓰기 잠금을 걸어야 한다

---

## SERIALIZABLE

단순하고 가장 엄격한 격리 수준입니다

트랜잭션에서 읽기, 쓰기를 진행중일 땐 다른 트랜잭션에서 접근이 불가합니다